package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
	
	//slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token) {
		report_error("\nSintaksna greska", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
			msg.append (" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}

:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, CONST, ASSIGN, SEMI, CLASS, COMMA;
terminal LBRACKET, RBRACKET, EXTENDS, LPAREN, RPAREN, VOID;
terminal IF, ELSE, WHILE, BREAK, CONTINUE, RETURN, PRINT, READ, DOT;
terminal FOREACH, ARROW, INC, DEC, OR, AND, NEW;
terminal EQ, NEQ, GR, GRE, LS, LSE, PLUS, MINUS, TIMES, DIV, MOD;
terminal Integer NUM;
terminal String IDENT;
terminal Boolean BOOL;
terminal char CHAR;

nonterminal Program Program;
nonterminal ItemDeclarations ItemDeclarations;
nonterminal MethodDeclarations MethodDeclarations;
nonterminal SingleConst SingleConst;
nonterminal ConstDecl ConstDecl;
nonterminal VarDeclarations VarDeclarations;
nonterminal ClassDecl ClassDecl;
nonterminal ClassBody ClassBody;
nonterminal ClassMethods ClassMethods;
nonterminal MethodOrCstrDeclarations MethodOrCstrDeclarations;
nonterminal FormParamList FormParamList;
nonterminal FormPars FormPars;
nonterminal FormParam FormParam;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal IfHeader IfHeader;
nonterminal ElseHeader ElseHeader;
nonterminal Empty Empty;
nonterminal WhileHeader WhileHeader;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ListDesignator ListDesignator;
nonterminal AdditionalDesignators AdditionalDesignators;
nonterminal ActPars ActPars;
nonterminal ActParList ActParList;
nonterminal AssignDesignatorStatement AssignDesignatorStatement;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal MrtvaZapeta MrtvaZapeta;

//dodati ili izmenjeni za semanticku analizu
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ClassName, MethodName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr, ExprList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarDecl, SingleVar, VarNonEmpty;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, FunType, ConstDeclarations;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, CondTerm, CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ForeachIterIdent;

precedence left ELSE;

Program ::= (Program) PROG ProgName:P1 ItemDeclarations:I2 LBRACE MethodDeclarations:M3 RBRACE {: RESULT=new Program(P1, I2, M3); RESULT.setLine(P1left); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

ItemDeclarations ::=	(ConstItemDecl) ItemDeclarations:I1 ConstDeclarations:C2 {: RESULT=new ConstItemDecl(I1, C2); RESULT.setLine(I1left); :}
						|
						(VarItemDecl) ItemDeclarations:I1 VarNonEmpty:V2 {: RESULT=new VarItemDecl(I1, V2); RESULT.setLine(I1left); :}
						|
						(ClassItemDecl) ItemDeclarations:I1 ClassDecl:C2 {: RESULT=new ClassItemDecl(I1, C2); RESULT.setLine(I1left); :}
						|
						(NoItemDecl) {: RESULT=new NoItemDecl(); :} /* epsilon */
						;

ConstDeclarations ::= (ConstDeclarations) CONST Type:constType ConstDecl:C1 SEMI {: RESULT=new ConstDeclarations(constType, C1); RESULT.setLine(constTypeleft); :};

ConstDecl ::= 	(MultipleConstDecl) ConstDecl:C1 COMMA IDENT:constName ASSIGN SingleConst:constVal {: RESULT=new MultipleConstDecl(C1, constName, constVal); RESULT.setLine(C1left); :}
				|
				(SingleConstDecl) IDENT:constName ASSIGN SingleConst:constVal {: RESULT=new SingleConstDecl(constName, constVal); RESULT.setLine(constNameleft); :}
				;

SingleConst ::= (NumConst) NUM:constVal {: RESULT=new NumConst(constVal); RESULT.setLine(constValleft); :}
				|
				(CharConst) CHAR:constVal {: RESULT=new CharConst(constVal); RESULT.setLine(constValleft); :}
				|
				(BoolConst) BOOL:constVal {: RESULT=new BoolConst(constVal); RESULT.setLine(constValleft); :}
				;

VarNonEmpty ::= (VarNonEmptyDecl) Type:varType VarDecl:varDecl SEMI {: RESULT=new VarNonEmptyDecl(varType, varDecl); RESULT.setLine(varTypeleft); :}
				;

VarDeclarations ::= (MultipleVarDeclarations) VarDeclarations:V1 Type:varType VarDecl:V2 SEMI {: RESULT=new MultipleVarDeclarations(V1, varType, V2); RESULT.setLine(V1left); :}
					|
					(NoVarDeclarations) {: RESULT=new NoVarDeclarations(); :} /* epsilon */
					;

VarDecl ::= (MultipleVarDecl) VarDecl:varDecl COMMA SingleVar:singleVar {: RESULT=new MultipleVarDecl(varDecl, singleVar); RESULT.setLine(varDeclleft); :}
			|
			(SingleVarDecl) SingleVar:singleVar {: RESULT=new SingleVarDecl(singleVar); RESULT.setLine(singleVarleft); :}
			;
			
					 
SingleVar ::= 	(VarArray) IDENT:varName LBRACKET RBRACKET {: RESULT=new VarArray(varName); RESULT.setLine(varNameleft); :}
				|
				(VarNoArray) IDENT:varName {: RESULT=new VarNoArray(varName); RESULT.setLine(varNameleft); :}
				;

ClassDecl ::= 	(ClassDecl) CLASS ClassName:C1 LBRACE ClassBody:C2 RBRACE {: RESULT=new ClassDecl(C1, C2); RESULT.setLine(C1left); :};
				
ClassName ::=	(ClassNameExtends) IDENT:className EXTENDS Type:extendsType {: RESULT=new ClassNameExtends(className, extendsType); RESULT.setLine(classNameleft); :} 
				|
				(ClassNameNoExtends) IDENT:className {: RESULT=new ClassNameNoExtends(className); RESULT.setLine(classNameleft); :}
				;
				
ClassBody ::=	(ClassBody) VarDeclarations:V1 ClassMethods:C2 {: RESULT=new ClassBody(V1, C2); RESULT.setLine(V1left); :};

ClassMethods ::= 	(ClassOnlyBraces) LBRACE MethodOrCstrDeclarations:M1 RBRACE {: RESULT=new ClassOnlyBraces(M1); RESULT.setLine(M1left); :}
					|
					(ClassNoCstrNoMethods) {: RESULT=new ClassNoCstrNoMethods(); :} /* epsilon */
					;

MethodOrCstrDeclarations ::=	(TypeMethodDecl) MethodOrCstrDeclarations:M1 FunType:funType MethodName:M2 LPAREN FormPars:F3 RPAREN VarDeclarations:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new TypeMethodDecl(M1, funType, M2, F3, V4, S5); RESULT.setLine(M1left); :}
								|
								(CstrDecl) MethodOrCstrDeclarations:M1 MethodName:M2 LPAREN FormPars:F3 RPAREN VarDeclarations:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new CstrDecl(M1, M2, F3, V4, S5); RESULT.setLine(M1left); :}
								|
								(VoidMethodDecl) MethodOrCstrDeclarations:M1 VOID MethodName:M2 LPAREN FormPars:F3 RPAREN VarDeclarations:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new VoidMethodDecl(M1, M2, F3, V4, S5); RESULT.setLine(M1left); :}
								|
								(NoCstrOrMethodDecl) {: RESULT=new NoCstrOrMethodDecl(); :} /* epsilon */
								;	

FunType ::= (FunType) Type:retType {: RESULT=new FunType(retType); RESULT.setLine(retTypeleft); :};

MethodDeclarations ::=	(TypeMethodDeclarations) MethodDeclarations:M1 FunType:funType MethodName:M2 LPAREN FormPars:F3 RPAREN VarDeclarations:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new TypeMethodDeclarations(M1, funType, M2, F3, V4, S5); RESULT.setLine(M1left); :}
						|
						(VoidMethodDeclarations) MethodDeclarations:M1 VOID MethodName:M2 LPAREN FormPars:F3 RPAREN VarDeclarations:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new VoidMethodDeclarations(M1, M2, F3, V4, S5); RESULT.setLine(M1left); :}
						|
						(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */
						;

MethodName ::= (MethodName) IDENT:funName {: RESULT=new MethodName(funName); RESULT.setLine(funNameleft); :};

FormPars ::= 	(FormParsNonEmpty) FormParamList:F1 {: RESULT=new FormParsNonEmpty(F1); RESULT.setLine(F1left); :}
				|
				(NoFormPars) {: RESULT=new NoFormPars(); :} /* epsilon */
				;
				
FormParamList ::=	(FormalParamList) FormParamList:F1 COMMA FormParam:F2 {: RESULT=new FormalParamList(F1, F2); RESULT.setLine(F1left); :}
					|
					(SingleFormalParam) FormParam:F1 {: RESULT=new SingleFormalParam(F1); RESULT.setLine(F1left); :}
					;

FormParam ::= 	(FormParamArray) Type:paramType IDENT:paramName LBRACKET RBRACKET {: RESULT=new FormParamArray(paramType, paramName); RESULT.setLine(paramTypeleft); :}
				|
				(FormParamNoArray) Type:paramType IDENT:paramName {: RESULT=new FormParamNoArray(paramType, paramName); RESULT.setLine(paramTypeleft); :}
				;

Type ::= (Type) IDENT:name {: RESULT=new Type(name); RESULT.setLine(nameleft); :};

StatementList ::= 	(StatementListNonEmpty) StatementList:S1 Statement:S2 {: RESULT=new StatementListNonEmpty(S1, S2); RESULT.setLine(S1left); :}
					|
					(NoStatements) {: RESULT=new NoStatements(); :} /* epsilon */
					;
					
Statement ::=	(StatementDesiStatement) DesignatorStatement:D1 SEMI {: RESULT=new StatementDesiStatement(D1); RESULT.setLine(D1left); :}
				|
				(IfStatement) IfHeader:I1 LPAREN Condition:C2 RPAREN Empty:E3 Statement:S4 {: RESULT=new IfStatement(I1, C2, E3, S4); RESULT.setLine(I1left); :}
				//|
				//(IfStatementError) IfHeader LPAREN error RPAREN:l
				//{: parser.report_error("Izvrsen oporavak u liniji " + lleft, null); :}
				//Empty Statement
				|
				(IfElseStatement) IfHeader:I1 LPAREN Condition:C2 RPAREN Empty:E3 Statement:S4 ElseHeader:E5 Statement:S6 {: RESULT=new IfElseStatement(I1, C2, E3, S4, E5, S6); RESULT.setLine(I1left); :}
				//|
				//(IfElseStatementError) IfHeader LPAREN error RPAREN:l
				//{: parser.report_error("Izvrsen oporavak u liniji " + lleft, null); :}
				 //Empty Statement ElseHeader Statement
				|
				(WhileStatement) WhileHeader:W1 LPAREN Condition:C2 RPAREN Empty:E3 Statement:S4 {: RESULT=new WhileStatement(W1, C2, E3, S4); RESULT.setLine(W1left); :}
				|
				(BreakStatement) BREAK SEMI {: RESULT=new BreakStatement(); :}
				|
				(ContinueStatement) CONTINUE SEMI {: RESULT=new ContinueStatement(); :}
				|
				(ReturnStatementEmpty) RETURN SEMI {: RESULT=new ReturnStatementEmpty(); :}
				|
				(ReturnStatementNonEmpty) RETURN Expr:E1 SEMI {: RESULT=new ReturnStatementNonEmpty(E1); RESULT.setLine(E1left); :}
				|
				(ReadStatement) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
				|
				(PrintStatementNoWidth) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new PrintStatementNoWidth(E1); RESULT.setLine(E1left); :}
				|
				(PrintStatementWidth) PRINT LPAREN Expr:E1 COMMA NUM:width RPAREN SEMI {: RESULT=new PrintStatementWidth(E1, width); RESULT.setLine(E1left); :}
				|
				(ForeachStatement) Designator:D1 DOT FOREACH LPAREN ForeachIterIdent:F2 ARROW Statement:S3 RPAREN SEMI {: RESULT=new ForeachStatement(D1, F2, S3); RESULT.setLine(D1left); :}
				|
				(MultipleStatements) LBRACE StatementList:S1 RBRACE {: RESULT=new MultipleStatements(S1); RESULT.setLine(S1left); :}
				;
				
Empty ::= (Empty) {: RESULT=new Empty(); :};
				
IfHeader ::= (IfHeader) IF {: RESULT=new IfHeader(); :};
				
ElseHeader ::= (ElseHeader) ELSE {: RESULT=new ElseHeader(); :};

WhileHeader ::= (WhileHeader) WHILE {: RESULT=new WhileHeader(); :};
				
ForeachIterIdent ::= (ForeachIterIdent) IDENT:iterName {: RESULT=new ForeachIterIdent(iterName); RESULT.setLine(iterNameleft); :};
				
DesignatorStatement ::=	(DesiStatementAssign) AssignDesignatorStatement:A1 {: RESULT=new DesiStatementAssign(A1); RESULT.setLine(A1left); :}
						|
						(DesiStatementActPars) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DesiStatementActPars(D1, A2); RESULT.setLine(D1left); :}
						|
						(DesiStatementInc) Designator:D1 INC {: RESULT=new DesiStatementInc(D1); RESULT.setLine(D1left); :}
						|
						(DesiStatementDec) Designator:D1 DEC {: RESULT=new DesiStatementDec(D1); RESULT.setLine(D1left); :}
						|
						(DesiStatementArrayAssign) LBRACKET ListDesignator:L1 RBRACKET ASSIGN Designator:D2 {: RESULT=new DesiStatementArrayAssign(L1, D2); RESULT.setLine(L1left); :}
						;
						
AssignDesignatorStatement ::= 	(AssignDesignatorStmt) Designator:D1 Assignop:A2 Expr:assignedVal {: RESULT=new AssignDesignatorStmt(D1, A2, assignedVal); RESULT.setLine(D1left); :}
								|
								(ErrorAssignDesignatorStmt) error SEMI:l
				 				{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new ErrorAssignDesignatorStmt(); :}
				 				;	
						
ListDesignator ::=	(ListDesiStartWithComma) AdditionalDesignators:A1 {: RESULT=new ListDesiStartWithComma(A1); RESULT.setLine(A1left); :}
					|
 					(ListDesiStartWithDesi) Designator:D1 AdditionalDesignators:A2 {: RESULT=new ListDesiStartWithDesi(D1, A2); RESULT.setLine(D1left); :}
 					;
 					
AdditionalDesignators ::=	(AdditionalDesiOnlyComma) MrtvaZapeta:M1 AdditionalDesignators:A2 {: RESULT=new AdditionalDesiOnlyComma(M1, A2); RESULT.setLine(M1left); :} 
							|
							(AdditionalDesiWithDesi) COMMA Designator:D1 AdditionalDesignators:A2 {: RESULT=new AdditionalDesiWithDesi(D1, A2); RESULT.setLine(D1left); :} 
							|
							(NoAdditionalDesi) {: RESULT=new NoAdditionalDesi(); :} /* epsilon */
							;
							
MrtvaZapeta ::= (MrtvaZapeta) COMMA {: RESULT=new MrtvaZapeta(); :};
 
Condition ::=	(SingleCondition) CondTerm:valLeft {: RESULT=new SingleCondition(valLeft); RESULT.setLine(valLeftleft); :}
 				|
 				(ConditionDisjunction) Condition:valLeft OR CondTerm:valRight {: RESULT=new ConditionDisjunction(valLeft, valRight); RESULT.setLine(valLeftleft); :}
 				;
 				
CondTerm ::=	(SingleCondTerm) CondFact:valLeft {: RESULT=new SingleCondTerm(valLeft); RESULT.setLine(valLeftleft); :}
				|
				(CondTermConjunction) CondTerm:valLeft AND CondFact:valRight {: RESULT=new CondTermConjunction(valLeft, valRight); RESULT.setLine(valLeftleft); :}
				;

CondFact ::=	(CondFactExpr) Expr:valLeft {: RESULT=new CondFactExpr(valLeft); RESULT.setLine(valLeftleft); :}
				|
				(CondFactRel) Expr:valLeft Relop:R1 Expr:valRight {: RESULT=new CondFactRel(valLeft, R1, valRight); RESULT.setLine(valLeftleft); :}
				;
 
 
ActPars ::=	(ActParsNonEmpty) ActParList:A1 {: RESULT=new ActParsNonEmpty(A1); RESULT.setLine(A1left); :}  
			|
			(NoActPars) {: RESULT=new NoActPars(); :} /* epsilon */
			;
				
ActParList ::=	(SingleActPar) Expr:E1 {: RESULT=new SingleActPar(E1); RESULT.setLine(E1left); :}
				|
				(MultipleActPars) ActParList:A1 COMMA Expr:E2 {: RESULT=new MultipleActPars(A1, E2); RESULT.setLine(A1left); :}
				;
					
Expr ::=	(NegExpr) MINUS Term:val {: RESULT=new NegExpr(val); RESULT.setLine(valleft); :}
 			|
 			(PosExpr) Term:val {: RESULT=new PosExpr(val); RESULT.setLine(valleft); :}
 			|
			(ExprMultipleTerms) Expr:exval Addop:A1 Term:tval {: RESULT=new ExprMultipleTerms(exval, A1, tval); RESULT.setLine(exvalleft); :}
			;
 			

 
Term ::=	(SingleTerm) Factor:fval {: RESULT=new SingleTerm(fval); RESULT.setLine(fvalleft); :}
			|
			(MultipleTerm) Term:tval Mulop:M1 Factor:fval {: RESULT=new MultipleTerm(tval, M1, fval); RESULT.setLine(tvalleft); :}
			;
			
Factor ::=	(FactorFuncCall) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorFuncCall(D1, A2); RESULT.setLine(D1left); :}
 			|
 			(FactorDesi) Designator:D1 {: RESULT=new FactorDesi(D1); RESULT.setLine(D1left); :}
 			|
 			(FactorNum) NUM:val {: RESULT=new FactorNum(val); RESULT.setLine(valleft); :}
 			|
 			(FactorChar) CHAR:val {: RESULT=new FactorChar(val); RESULT.setLine(valleft); :}
 			|
 			(FactorBool) BOOL:val {: RESULT=new FactorBool(val); RESULT.setLine(valleft); :}
 			|
 			(FactorExprInParen) LPAREN Expr:E1 RPAREN {: RESULT=new FactorExprInParen(E1); RESULT.setLine(E1left); :}
 			|
 			(FactorNewArray) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new FactorNewArray(T1, E2); RESULT.setLine(T1left); :}
 			|
 			(FactorNewCstr) NEW Type:T1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorNewCstr(T1, A2); RESULT.setLine(T1left); :}
 			;
 			
 				
Designator ::=	(DesiOnlyIdent) IDENT:desiName {: RESULT=new DesiOnlyIdent(desiName); RESULT.setLine(desiNameleft); :}
				|
				(DesiDot) Designator:D1 DOT IDENT:attrName {: RESULT=new DesiDot(D1, attrName); RESULT.setLine(D1left); :}
				|
				(DesiArray) Designator:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesiArray(D1, E2); RESULT.setLine(D1left); :} 
				;
			
Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Relop ::=	(RelEq) EQ {: RESULT=new RelEq(); :}
			|
			(RelNeq) NEQ {: RESULT=new RelNeq(); :}
			|
			(RelGr) GR {: RESULT=new RelGr(); :}
			|
			(RelGre) GRE {: RESULT=new RelGre(); :}
			|
			(RelLs) LS {: RESULT=new RelLs(); :}
			|
			(RelLse) LSE {: RESULT=new RelLse(); :}
			;
			
Addop ::=	(Addition) PLUS {: RESULT=new Addition(); :}
			|
			(Subtraction) MINUS {: RESULT=new Subtraction(); :}
			;
			
Mulop ::=	(Multiplication) TIMES {: RESULT=new Multiplication(); :}
			|
			(Division) DIV {: RESULT=new Division(); :}
			|
			(Mod) MOD {: RESULT=new Mod(); :}
			;
						