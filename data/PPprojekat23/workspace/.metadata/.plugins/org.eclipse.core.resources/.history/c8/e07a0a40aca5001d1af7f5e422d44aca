package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
	
	//slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token) {
		report_error("\nSintaksna greska", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
			msg.append (" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}

:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, CONST, ASSIGN, SEMI, CLASS, COMMA;
terminal LBRACKET, RBRACKET, EXTENDS, LPAREN, RPAREN, VOID;
terminal IF, ELSE, WHILE, BREAK, CONTINUE, RETURN, PRINT, READ, DOT;
terminal FOREACH, ARROW, INC, DEC, OR, AND, NEW;
terminal EQ, NEQ, GR, GRE, LS, LSE, PLUS, MINUS, TIMES, DIV, MOD;
terminal Integer NUM;
terminal String IDENT;
terminal Boolean BOOL;
terminal char CHAR;

nonterminal Program, ItemDeclarations, MethodDeclarations;
nonterminal SingleConst, ConstDecl;
nonterminal VarDeclarations;
nonterminal ClassDecl, ClassBody, ClassMethods;
nonterminal MethodOrCstrDeclarations;
nonterminal FormParamList, FormPars, FormParam;
nonterminal StatementList, Statement;
nonterminal IfHeader, ElseHeader;
nonterminal Empty, WhileHeader;
nonterminal DesignatorStatement, ListDesignator, AdditionalDesignators;
nonterminal ActPars, ActParList, AssignDesignatorStatement;
nonterminal Assignop, Relop, Addop, Mulop;
nonterminal MrtvaZapeta;

//dodati ili izmenjeni za semanticku analizu
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ClassName, MethodName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr, ExprList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarDecl, SingleVar, VarNonEmpty;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, FunType, ConstDeclarations;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, CondTerm, CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ForeachIterIdent;

precedence left ELSE;

Program ::= (Program) PROG ProgName ItemDeclarations LBRACE MethodDeclarations RBRACE;

ProgName ::= (ProgName) IDENT:progName;

ItemDeclarations ::=	(ConstItemDecl) ItemDeclarations ConstDeclarations
						|
						(VarItemDecl) ItemDeclarations VarNonEmpty
						|
						(ClassItemDecl) ItemDeclarations ClassDecl
						|
						(NoItemDecl) /* epsilon */
						;

ConstDeclarations ::= (ConstDeclarations) CONST Type:constType ConstDecl SEMI;

ConstDecl ::= 	(MultipleConstDecl) ConstDecl COMMA IDENT:constName ASSIGN SingleConst:constVal
				|
				(SingleConstDecl) IDENT:constName ASSIGN SingleConst:constVal
				;

SingleConst ::= (NumConst) NUM:constVal
				|
				(CharConst) CHAR:constVal
				|
				(BoolConst) BOOL:constVal
				;

VarNonEmpty ::= (VarNonEmptyDecl) Type:varType VarDecl:varDecl SEMI
				;

VarDeclarations ::= (MultipleVarDeclarations) VarDeclarations Type:varType VarDecl SEMI
					|
					(NoVarDeclarations) /* epsilon */
					;

VarDecl ::= (MultipleVarDecl) VarDecl:varDecl COMMA SingleVar:singleVar
			|
			(SingleVarDecl) SingleVar:singleVar
			//|
				//(ErrorVarSemi) error SEMI:l
 				//{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
 				;
					 
SingleVar ::= 	(VarArray) IDENT:varName LBRACKET RBRACKET
				|
				(VarNoArray) IDENT:varName
				//|
				//(ErrorVarComma) error COMMA:l
				//{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null); :}
				;

ClassDecl ::= 	(ClassDecl) CLASS ClassName LBRACE ClassBody RBRACE;
				
ClassName ::=	(ClassNameExtends) IDENT:className EXTENDS Type:extendsType 
				|
				(ClassNameNoExtends) IDENT:className
				;
				
ClassBody ::=	(ClassBody) VarDeclarations ClassMethods;

ClassMethods ::= 	(ClassOnlyBraces) LBRACE MethodOrCstrDeclarations RBRACE
					|
					(ClassNoCstrNoMethods) /* epsilon */
					;

MethodOrCstrDeclarations ::=	(TypeMethodDecl) MethodOrCstrDeclarations FunType:funType MethodName LPAREN FormPars RPAREN VarDeclarations LBRACE StatementList RBRACE
								|
								(CstrDecl) MethodOrCstrDeclarations MethodName LPAREN FormPars RPAREN VarDeclarations LBRACE StatementList RBRACE
								|
								(VoidMethodDecl) MethodOrCstrDeclarations VOID MethodName LPAREN FormPars RPAREN VarDeclarations LBRACE StatementList RBRACE
								|
								(NoCstrOrMethodDecl) /* epsilon */
								;	

FunType ::= (FunType) Type:retType;

MethodDeclarations ::=	(TypeMethodDeclarations) MethodDeclarations FunType:funType MethodName LPAREN FormPars RPAREN VarDeclarations LBRACE StatementList RBRACE
						|
						(VoidMethodDeclarations) MethodDeclarations VOID MethodName LPAREN FormPars RPAREN VarDeclarations LBRACE StatementList RBRACE
						|
						(NoMethodDeclarations) /* epsilon */
						;

MethodName ::= (MethodName) IDENT:funName;

FormPars ::= 	(FormParsNonEmpty) FormParamList
				|
				(NoFormPars) /* epsilon */
				;
				
FormParamList ::=	(FormalParamList) FormParamList COMMA FormParam
					|
					(SingleFormalParam) FormParam
					;

FormParam ::= 	(FormParamArray) Type:paramType IDENT:paramName LBRACKET RBRACKET
				|
				(FormParamNoArray) Type:paramType IDENT:paramName
				;

Type ::= (Type) IDENT:name;

StatementList ::= 	(StatementListNonEmpty) StatementList Statement
					|
					(NoStatements) /* epsilon */
					;
					
Statement ::=	(StatementDesiStatement) DesignatorStatement SEMI
				|
				(IfStatement) IfHeader LPAREN Condition RPAREN Empty Statement
				//|
				//(IfStatementError) IfHeader LPAREN error RPAREN:l
				//{: parser.report_error("Izvrsen oporavak u liniji " + lleft, null); :}
				//Empty Statement
				|
				(IfElseStatement) IfHeader LPAREN Condition RPAREN Empty Statement ElseHeader Statement
				//|
				//(IfElseStatementError) IfHeader LPAREN error RPAREN:l
				//{: parser.report_error("Izvrsen oporavak u liniji " + lleft, null); :}
				 //Empty Statement ElseHeader Statement
				|
				(WhileStatement) WhileHeader LPAREN Condition RPAREN Empty Statement
				|
				(BreakStatement) BREAK SEMI
				|
				(ContinueStatement) CONTINUE SEMI
				|
				(ReturnStatementEmpty) RETURN SEMI
				|
				(ReturnStatementNonEmpty) RETURN Expr SEMI
				|
				(ReadStatement) READ LPAREN Designator RPAREN SEMI
				|
				(PrintStatementNoWidth) PRINT LPAREN Expr RPAREN SEMI
				|
				(PrintStatementWidth) PRINT LPAREN Expr COMMA NUM:width RPAREN SEMI
				|
				(ForeachStatement) Designator DOT FOREACH LPAREN ForeachIterIdent ARROW Statement RPAREN SEMI
				|
				(MultipleStatements) LBRACE StatementList RBRACE
				;
				
Empty ::= (Empty);
				
IfHeader ::= (IfHeader) IF;
				
ElseHeader ::= (ElseHeader) ELSE;

WhileHeader ::= (WhileHeader) WHILE;
				
ForeachIterIdent ::= (ForeachIterIdent) IDENT:iterName;
				
DesignatorStatement ::=	(DesiStatementAssign) AssignDesignatorStatement
						|
						(DesiStatementActPars) Designator LPAREN ActPars RPAREN
						|
						(DesiStatementInc) Designator INC
						|
						(DesiStatementDec) Designator DEC
						|
						(DesiStatementArrayAssign) LBRACKET ListDesignator RBRACKET ASSIGN Designator
						;
						
AssignDesignatorStatement ::= 	(AssignDesignatorStmt) Designator Assignop Expr:assignedVal
								|
								(ErrorAssignDesignatorStmt) error SEMI:l
				 				{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
				 				;	
						
ListDesignator ::=	(ListDesiStartWithComma) AdditionalDesignators
					|
 					(ListDesiStartWithDesi) Designator AdditionalDesignators
 					;
 					
AdditionalDesignators ::=	(AdditionalDesiOnlyComma) MrtvaZapeta AdditionalDesignators 
							|
							(AdditionalDesiWithDesi) COMMA Designator AdditionalDesignators 
							|
							(NoAdditionalDesi) /* epsilon */
							;
							
MrtvaZapeta ::= (MrtvaZapeta) COMMA;
 
Condition ::=	(SingleCondition) CondTerm:valLeft
 				|
 				(ConditionDisjunction) Condition:valLeft OR CondTerm:valRight
 				;
 				
CondTerm ::=	(SingleCondTerm) CondFact:valLeft
				|
				(CondTermConjunction) CondTerm:valLeft AND CondFact:valRight
				;

CondFact ::=	(CondFactExpr) Expr:valLeft
				|
				(CondFactRel) Expr:valLeft Relop Expr:valRight
				;
 
 
ActPars ::=	(ActParsNonEmpty) ActParList  
			|
			(NoActPars) /* epsilon */
			;
				
ActParList ::=	(SingleActPar) Expr
				|
				(MultipleActPars) ActParList COMMA Expr
				;
					
Expr ::=	(NegExpr) MINUS Term:val
 			|
 			(PosExpr) Term:val
 			|
			(ExprMultipleTerms) Expr:exval Addop Term:tval
			;
 			

 
Term ::=	(SingleTerm) Factor:fval
			|
			(MultipleTerm) Term:tval Mulop Factor:fval
			;
			
Factor ::=	(FactorFuncCall) Designator LPAREN ActPars RPAREN
 			|
 			(FactorDesi) Designator
 			|
 			(FactorNum) NUM:val
 			|
 			(FactorChar) CHAR:val
 			|
 			(FactorBool) BOOL:val
 			|
 			(FactorExprInParen) LPAREN Expr RPAREN
 			|
 			(FactorNewArray) NEW Type LBRACKET Expr RBRACKET
 			|
 			(FactorNewCstr) NEW Type LPAREN ActPars RPAREN
 			;
 			
 				
Designator ::=	(DesiOnlyIdent) IDENT:desiName
				|
				(DesiDot) Designator DOT IDENT:attrName
				|
				(DesiArray) Designator LBRACKET Expr RBRACKET 
				;
			
Assignop ::= (Assignop) ASSIGN;

Relop ::=	(RelEq) EQ
			|
			(RelNeq) NEQ
			|
			(RelGr) GR
			|
			(RelGre) GRE
			|
			(RelLs) LS
			|
			(RelLse) LSE
			;
			
Addop ::=	(Addition) PLUS
			|
			(Subtraction) MINUS
			;
			
Mulop ::=	(Multiplication) TIMES
			|
			(Division) DIV
			|
			(Mod) MOD
			;
						